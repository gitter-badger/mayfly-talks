:backend: revealjs
:revealjs_theme: black
//:revealjs_customtheme: theme/bol.com/bol.com.css
:revealjs_control: true
:revealjs_center: true
:revealjs_history: true
:revealjs_transition: linear
:source-highlighter: highlightjs
:highlightjs_style: highlight.js/styles/solarized_dark.css
// Relative to generated HTML
:imagesdir: ./images
////
Relative to original asciidoc document,
as source code is processed before creation
of the html-file
////
:sources: ../../

= Spock Framework
Patrick van Dissel <@pvdissel>
v1.0, 2015-03-10
:toc:


[data-background={imagesdir}/minions-oooooh.gif]
== !

[source,groovy]
----
include::{sources}/test/groovy/com/bol/spock/sample/AwesomeSpec.groovy[lines=6..9]
----

[NOTE.speaker]
--
Lets start-off with a sample of a typical Spock Specification
to get used to it.
Let it soak in for a bit..

From here on, I will explain how this all works
and what more there is
--


== Specification

Specification based, blablabla

[NOTE.speaker]
--
--

== Blocks -> Phases

image::Blocks2Phases.png[]

[NOTE.speaker]
--
--


[data-background={imagesdir}/minions-awesome.gif]
== Parameterized specs


== @Unroll

[NOTE.speaker]
--
--


[data-background={imagesdir}/minions-shake-light.gif]
== Extensions

[NOTE.speaker]
--
Some bundled extensions, are..
--


=== Ignore / Require

[source,groovy]
----
@spock.lang.Ignore(reason = "TODO")
def "my feature"() { ... }
----

[source,groovy]
----
@spock.lang.IgnoreRest
def "I'll run"() { ... }
----

[source,groovy]
----
@spock.lang.IgnoreIf({ os.windows })
def "I'll run everywhere but on Windows"() { ... }
----

[source,groovy]
----
@spock.lang.Requires({ os.windows })
def "I'll only run on Windows"() { ... }
----

[NOTE.speaker]
--
To make predicates easier to read and write, +
the following properties are available inside the closure:

- `sys` A map of all system properties
- `env` A map of all environment variables
- `os` Information about the operating system +
  (see `spock.util.environment.OperatingSystem)`
- `jvm` Information about the JVM +
  (see `spock.util.environment.Jvm`)
--


=== Timeout

To fail a feature method, fixture, or class +
that exceeds a given execution duration, +
use `spock.lang.Timeout`

[source,groovy]
----
@Timeout(10)
class TimedSpec extends Specification {
  def "I fail after ten seconds"() { ... }
  def "Me too"() { ... }

  @Timeout(value = 250, unit = TimeUnit.MILLISECONDS)
  def "I fail much faster"() { ... }
}
----

[NOTE.speaker]
--
When applied to a feature method, +
the timeout is per execution of one iteration, +
excluding time spent in fixture methods.

Applying `Timeout` to a spec class +
has the same effect as applying it to each feature +
that is not already annotated with Timeout, +
excluding time spent in fixture methods.

When applied to a fixture method, +
the timeout is per execution of the fixture method.

When a timeout is reported to the user, +
the stack trace shown reflects the execution stack +
of the test framework when the timeout was exceeded.
--


=== Stepwise

To execute features in the order that they are declared, +
use `spock.lang.Stepwise`

[source,groovy]
----
@Stepwise
class RunInOrderSpec extends Specification {
  def "I run first"()  { ... }
  def "I run second"() { ... }
}
----

[NOTE.speaker]
--
`Stepwise` only affects the class carrying the annotation; +
not sub or super classes. +

Features after the first failure are skipped.
--


=== Title and Narrative

To attach a natural-language name to a spec, +
use `spock.lang.Title`

[source,groovy]
----
@Title("This is easy to read")
class ThisIsHarderToReadSpec { ... }
----

To attach a natural-language description to a spec, +
use `spock.lang.Narrative`

[source,groovy]
----
@Narrative(""""
As a user
I want foo
So that bar
""")
class GiveTheUserFooSpec { ... }
----


=== Subject

To indicate one or more subjects of a spec, +
use `spock.lang.Subject`

[source,groovy]
----
@Subject([Foo, Bar])
class MySpec { ... }
----

`Subject` can be applied to fields and local variables

[source,groovy]
----
@Subject
Foo myFoo
----

[NOTE.speaker]
--
`Subject` currently has only informational purposes.
--


=== Issue

To indicate that a feature or spec +
relates to one or more issues in an external tracking system, +
use `spock.lang.Issue`

[source,groovy]
----
@Issue("http://my.issues.org/FOO-1")
class MySpec {
  @Issue("http://my.issues.org/FOO-2")
  def "Foo should do bar"() { ... }

  @Issue(["http://my.issues.org/FOO-3",
          "http://my.issues.org/FOO-4"])
  def "I have two related issues"() { ... }
}
----

[NOTE.speaker]
--
`Issue` currently has only informational purposes.
--


=== Use

To activate one or more Groovy categories +
within the scope of a feature method or spec, +
use `spock.util.mop.Use`

[source,groovy]
----
class ListExtensions {
  static avg(List list) { list.sum() / list.size() }
}

class MySpec extends Specification {
  @Use(listExtensions)
  def "can use avg() method"() {
    expect:
    [1, 2, 3].avg() == 2
  }
}
----

[NOTE.speaker]
--
This can be useful for stubbing of dynamic methods,
which are usually provided by the runtime environment
(e.g. Grails). It has no effect when applied to a helper
method. However, when applied to a spec class,
it will also affect its helper methods.
--

=== ConfineMetaClassChanges

To confine meta class changes to the scope of a
feature method or spec class, +
use `spock.util.mop.ConfineMetaClassChanges`

[source,groovy]
----
@Stepwise
class FooSpec extends Specification {
  @ConfineMetaClassChanges
  def "I run first"() {
    when:
    String.metaClass.someMethod = { delegate }

    then:
    String.metaClass.hasMetaMethod('someMethod')
  }

  def "I run second"() {
    when:
    "Foo".someMethod()

    then:
    thrown(MissingMethodException)
  }
}
----

[NOTE.speaker]
--
When applied to a spec class, +
the meta classes are restored to the state +
that they were in before `setupSpec()` was executed, +
after cleanupSpec() is executed.

When applied to a feature method, +
the meta classes are restored to the state +
as they were after `setup()` was executed, +
before `cleanup()` is executed.
--


=== AutoCleanup

Automatically clean up a field or property +
at the end of its lifetime +
by using `spock.lang.AutoCleanup`

[source,groovy]
----
@AutoCleanup('dispose')
@AutoCleanup(quiet = true)
----

[NOTE.speaker]
--
By default, an object is cleaned up by invoking its parameterless `close()` method. +
If some other method should be called instead, override the annotation’s value attribute:

[source,groovy]
----
// invoke foo.dispose()
@AutoCleanup(“dispose”) def foo
----

If multiple fields or properties are annotated with `AutoCleanup`, +
their objects are cleaned up sequentially, +
in reverse field/property declaration order, +
starting from the most derived class +
and walking up the inheritance chain.

If a cleanup operation fails with an exception, +
the exception is reported by default, +
and cleanup proceeds with the next annotated object. +
To prevent cleanup exceptions from being reported, +
override the annootation’s `quite` attribute
--


=== title

[source,groovy]
----
----

[NOTE.speaker]
--
--

== Resources

- http://spockframework.org
- http://mrhaki.blogspot.nl/search/label/Spock
- Java Testing with Spock +
  http://manning.com/kapelonis/


